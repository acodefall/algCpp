#pragma once
#include <iostream>
#include <algorithm>
using namespace std;
namespace MedianOfTwoSortedArraysNM
{
	/*
			  1    2   3   6 (2)             4   6   8   10 (7)
					2  3  6(3)               4   6  8(6)
					   3  6                  4  6
						            5


									
			1    12   15   26   38(15)             2   13   17   30   45 (17)
					  15   26   38(26)             2   13   17(13)
					  15   26                          13   17
									    16

									
	
	Median for two sorted arrays_ 20170627011
		This logic applies only if the size of both the arrays is same.

		We use DAC. Our goal is to compute the median as if two array are stitched togather. Before stitching, we have to shrink the 1st and 2nd array in to length either 1 or 2, and after that we can combine the element together. Shrinking of array uses DAC logic.

		At the highest level of DAC, separately compute the median for 1st array and 2nd array, taking all the elements in to account. In the next round, separately compute the median for 'half of 1st array' and 'half of 2nd array'. In the next round, separately compute the median for half of ‘half-parts’. When array length shrinks to either 2 or 1 elements, then compute combined Median. DAC will have LongN levels. At each level we discard half and process other half.(to compare with merge sort, there we process both the sections)

		Next question is which half of the array is considered and which is discarded.This depends on relative value of the medians generated by 1st and 2nd arrays. To understand this logic, assume that and 1st and 2nd array are making a circle because they are sorted.
		(1st-array's median > 2nd-array's median) then select the 1st-half-of-1st-array, 2nd-half-of-2nd-array, and discard the rest.
		(2nd-array's median > 1st-array's median) then Select the 2nd-half-of-1st-array, 1st-half-of-2nd-array, and discard the rest.
		Irrespective of which subpart we select, the subarray, passed to recursion, should include the elements used for computing median for current-round. Keep in mind middle elements contribute to MEDIAN, so the that the Median is nothing but mid-element OR two-of-center elements. Subarray passed to recursion should include these array elements.
		So when making the recursion call, make two checks
		-compare med1 and med2, and decide about which partition to send to recursion.
		-check whether the array length is EVEN or ODD.
		If EVEN, subarray should begin at (&src[0] + Len/2 -1). We subtract one(-1) to include the elements that is before and after the CENTER. Appropriately, SubArrayLen should be (len - len/2) + 1;

		If ODD, subarray should begin at (Len/2). In this case only center element contributes to mdian. Appropriately ArrayLen will be (len- len/2);


		if (len1 % 2 == 0)
			return findMedianForToArray(src1, (&src2[0] + (len/2 - 1)), (len - len/2) + 1);
		else
			return findMedianForToArray( src1, (&src2[0] + (len/2)), (len - len/2));
		When computing subarray-len, use (Len - Len/2), not just Len/2. The difference matters ODD length. So to be on safer side always use (Len - Len/2), not just Len/2.

		Depending on whether array size is EVEN or ODD, the DAC will shrink the array length to either 1 or 2 elements.
		If the array shrinks to 1 element each, compute the median by dividing the sum by 2.
		If the array shrinks to 2 elements each, add MAX(1st element) + MIN(2nd element), and divide the sum by 2. Reason for for MIN and MAX is; say 1st array has {1, 10} and 2nd array has {5, 20}, we need to cover the range “5 and 10”; so we use MAX of 1st element and MIN of 2nd element.


	Steps for finding median of two sorted arrays_20170627012
		1) parameters for recursion are src1[] and src2[] and len
		Len gives the length of arrays. both arrays will have same size
		2)Inside the function, first handle the condition when rray has shrunk to 0, 1, 2
		These are exit condition for recursion. So return
		if(len <= 0)
			Return
		if(len == 1)
			Arrays have shrunk to minimum size, compute the median and RETURN it
		if(len == 2)
			Arrays have shrunk to minimum size, compute the median and RETURN it
			Take (MaxOf[0] and MinOf[1])/2
			Return the median

		3) Otherwise array size is still high and needs to undergo DAC
		4) Compute the Median for src1 and src2
		5) if(M1 == M2)
			We found the median EXIT
		6) 	We need to make recursion call to subdivide half of current.
		There are 4 different ways to make recursion call, depending whether (M1 > M2) and (M2 > M1)
		Under each one of them taken in to account whether len is even or odd.
		These factor affect
		-beginOffSet of sub array
		-length of sub array
		If(EVEN)
			two elements were used for median computation so
			OFFSET = "(len/2) - 1"
			LEN =  "(len - len/2) + 1"
		If(ODD)
			one element was used for median computation so
			OFFSET = "(len/2)"
			LEN =  "(len - len/2)"


		if(M1 > M2)
			select the 1st-half-of-1st-array, 2nd-half-of-2nd-array, and discard the rest.

		if(M2 > M1)
			Select the 2nd-half-of-1st-array, 1st-half-of-2nd-array, and discard the rest.
		7)  Then make the recursion call and return their values


		
	*/
	class MedianOfTwoSortedArrays
	{
		public:
				void CallMedianOfTwoSortedArrays()
				{
					//int src1[] = { 1, 2, 3, 6 };
					//int src2[] = { 4,6,8,10};  //5
					//int med = findMedianForToArray(src1, src2, 4); //5
					//cout << "median " << med << endl;
					int src1[] = { 1, 12, 15, 26, 38 };
					int src2[] = { 2, 13, 17, 30, 45 }; //16

					int med = findMedianForToArray(src1, src2, 5);
					cout << "median " << med << endl; 
				}


				int findMedianForToArray(int* src1, int* src2, int len)
				{
					int median = 0;

					if (len <= 0)
						return -1;
					
					//array content
					cout << endl << "Array content" << endl << " size: " << len << endl;
					for (int i = 0; i < len; i++)
					{
						cout << src1[i] << " ";
					}
					cout << endl;
					for (int i = 0; i < len; i++)
					{
						cout << src2[i] << " ";
					}

					cout << endl;

					//Depending on whether array size is EVEN or ODD, the DAC will shrink the array length to either 1 or 2 elements.
					//when the two arrays of same size
					if (len == 1)
					{
						median = (src1[0] + src2[0]) / 2;
						return median;
					}
					if (len == 2)
					{	//Reason for for MIN and MAX is; say 1st array has {1, 10} and 2nd array has {5, 20}, we need to cover the range “5 and 10”; so we use MAX of 1st element and MIN of 2nd element.
						median = (max(src1[0], src2[0]) + min(src1[1], src2[1])) / 2;
						return median;
					}
					

					int med1 = findMedianOneArray(src1, len);
					int med2 = findMedianOneArray(src2, len);

					//To understand this imagine the two arrays are forming a circle
					if (med1 == med2)
					{
						return med1;
					}
					else if (med1 > med2)
					{	// use (Len - Len/2), not just Len/2. The difference matters for ODD length. 
						if (len % 2 == 0)
							return findMedianForToArray(src1, (&src2[0] + (len / 2 - 1)), (len - len / 2) + 1);
						return findMedianForToArray( src1, (&src2[0] + (len / 2)), (len - len / 2));
					}
					else
					{	// use (Len - Len/2), not just Len/2. The difference matters for ODD length. 
						if (len % 2 == 0)
							return findMedianForToArray((&src1[0] + (len/2 - 1)), src2, (len - len/2) + 1);
						return findMedianForToArray((&src1[0] + (len / 2)), src2, (len - len/2));
					}
					return median;
				}

				int findMedianOneArray(int src[], int len)
				{
					
					//int med1 =
					//compute the median 
					int median = 0;
					if (len > 0)
					{
						//1 2 3 4 = 2
						if (len % 2 == 0)
						{
							median = (src[len / 2] + src[(len - 1) / 2]) / 2;
						}
						else if ((len % 2) != 0)
						{
							median = src[len / 2];
						}
					}
					else
					{
						median = src[0];
					}

					
					cout << endl << "Median : " << median << endl;
					return median;
				}
				
	};
};