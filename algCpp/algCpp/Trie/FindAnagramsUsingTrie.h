#pragma once
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <list>
#include <fstream>
#include <iomanip>
#include <unordered_set>
using namespace std;

namespace FindAnagramsUsingTrieNM
{

	/*								
		Print the Anagram and also the origianl words used to make the anagram using TRIE
			Think about anagram as signature used for representing several words.  
			Signature or Anagram can be generated by simply sorting the words. When we sort ‘Rat’ and ‘Art’ the generated signature is Art. Signatue or Anagram of words God and Dog is sorted word that is 'dgo'.

				God and Dog are anagrams. When asked to list the Anagram of Dog, program should return both Dog and God.
				In order to support this TRIE should connect 3 things: God, Dog and its anagram. 
				This can be done as follows. Maintains LL and TRIE.
				LL will have orginal word in its original form. Means it will have both God and Dog.
				TRIE will have sorted version of God and Dog. In fact sorted version of God and sorted version of Dog will lead to 
				the same Node. This node hold reference to the God and Dog stored in LL. TRIE will store the index of
				God and Dog that is in LL.

				This is implemented as follow:
				Insert(Dog)
					Store the Dog as it is in LL
					Sort Dog and store in TRIE, and TRIE node should also store the index of Dog in LL

				Insert(God)
					Store the God as it is in LL
					Sort God and store in TRIE, and TRIE node should also store the index of God in LL

				FetchAnagrams(God)
					Sort God and navigate to correspoonding node in TRIE.
					Node will have idexes to God and Dog stored in LL. Fetch Dog and God from LL.


			
	*/
	
	//Node used for storing Anagram and also the source words used for making Anagram.
	class TrieNode
	{
		public:
			map<char, TrieNode*> child;	//char will store each letter of Anagram 
			int eow;
			list<string> originalWord;	//Original Words who's anagram we are storing. Ex: If Anagram'dgo' represents Dog, God. 
										//Then TRIE will 'dgo' and originalWord will have Dog and God
			TrieNode()
			{
				eow = 0;
				for (int i = 'a'; i < ('a' + 26); i++)
				{
					child.insert(pair<char, TrieNode*>(i, 0));
				}
			}
	};

	class FindAnagramsUsingTrie
	{
	public:
		TrieNode* root;
		FindAnagramsUsingTrie()
		{
			root = new TrieNode();
		}
		
		//insert the word in to TRIE
		//sourceWords: are used for making anagram. Think about anagram as signature of word
		void addWord(char* anagram, list<string>& sourceWords)
		{
			TrieNode* cur = root;
			int len = strlen(anagram);
			for (int i = 0; i < len; i++)
			{
				//Iterate the word letter by letter and insert in to TRIE
				if (((int)anagram[i] >= 'a') && ((int)anagram[i] <= 'z'))
				{
					if (cur->child[anagram[i]] == 0)
					{
						cur->child[anagram[i]] = new TrieNode();
					}

					cur = (TrieNode*)cur->child[anagram[i]];
				}
			}

			//When we hit the last letter of WORD, so set EOW 
			if (cur != root)
			{	
				cur->eow = 1;
				if (sourceWords.size() > 0)
				{
					for (auto itr= sourceWords.begin(); itr != sourceWords.end(); itr++)
					{
						cur->originalWord.push_back(*itr);
					}
				}
			}
		}

		//We are interested in NonCompound word, means the word that has no letters after the first EOW node.
		//Cmpnd word will have letter after the node with EOW.
		//In case of both Cpmpd & NonCmpd words, do not make any more recursion calls; we do not want to go down any further after the first EOW node.
		//If the word is compund, do not record; otherwise record it.
		//Iterate from root and keep on checking for EOW. If the node has EOW and also has at least one non-null child node, then word is compound word. 
		//Do not record. If all of the child nodes are NULL, then word is non-compound word, record it.
		//In both the return, 
		void extractFirstWord(TrieNode* curIn, string anagram, list<string>& sourceWord)
		{
			const char* tmp = anagram.c_str();
			TrieNode* cur = curIn;
			for (int i = 0; i <= anagram.length(); i++) // "<=" is used because the Root node is not having the 1st letter of the word being searched.
			{		
				if (cur != NULL)
				{
					//First character is actually in 2nd node of the thread of nodes.
					if (cur->eow)
					{	//Exit as soon as we get 1st EOW. 
						//This marks the end of first the WORD
						//, check whether any child node is valid. Then WORD is compound, then do not record.
						//If all the child nodes are NULL, then WORD is non-compound, record it.
						sourceWord = cur->originalWord;
						return;
					}
					cur = cur->child[tmp[i]];
				}
			}
			return;
		}
		
		

	};

	class UseFindAnagramsUsingTrie
	{
	public:
		void CallUseFindAnagramsUsingTrie()
		{
			FindAnagramsUsingTrie objTrieM;
			
		


			
			

			//Original words provided by user will have both compound words and non-compound words, we have to seperate them.
			//We are intersted in compoundWords only. We do not care about non-compound words
			//We want to check whether the every subword of compound word is Root word.
			
			//DogCat This compound word because 'g' has EOW (frstWord Len < wholeWordLen)
			//Rat    This is not compound word because 't' has EOW and that happens be the end of whole word. (frstWord Len == wholeWordLen)
			string firstWord;
			for (auto itr = rawWordList.begin(); itr != rawWordList.end(); itr++)
			{
				objTrieM.extractFirstWord(objTrieM.root, (*itr) ,firstWord);
				if ((*itr).length() > firstWord.length())
				{
					//it is a compund word
					CompndWordList.insert({ (*itr),(*itr) });
				}
			}

			
			//Go through the list of compound words and record the longest word
			//find the LCW
			string wholeWord;
			string wordBtwnEOW;
			string longestLCW;
			
			objTrieM.TraverseAndFindLCW(objTrieM.root, totallyCompoundWord, CompndWordList, longestLCW);
			cout << "LCW is '"<< longestLCW.c_str() <<"'" << endl;
		
		}
	};

};