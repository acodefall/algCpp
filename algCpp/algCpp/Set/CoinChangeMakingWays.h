#pragma once
#include <iostream>
#include <list>
#include <string>
#include <map>
#include <stack>
#include <limits>
using namespace std;



/*
		Coin change problem
			-Count the number of combinations who's sum is equal to X
			-Find actual combinations who's sum adds to X
			
			Change making problem using permutations
			This program creates coins that add to a sum.			
				Ex: 2 + 2 = 4; and 1 + 3 = 4.
			As you see, the subset the "2 2" has duplcate elements so this is a Permutation problem. This is different from cutting-rod problem, that was 0-1 Knapsack problem, and we could use an item only once, no duplicates were allowed. But coin change problem allows duplicates elements.

			Solution will generate the permutations by making recursion calls from within a ForLoop.
			Since duplicates are allowed, the ForLoop at Each level of recursion iterates the src[] from 0 and until SrcLen.
			Evetry recursion creates new coin and adds it to permutation; so  permutation grows by one more slot, and this new coin gets added to the SUM, and SUM gets passed as recursion param. In the next round of recursion, we check the SUM; if the SUM has reached the TargetSum, we break the recursion. Number recursions to reach the Target Sum depends on value of individual coins. Ex: 4 can be generated by using "1 1 1 1" OR "2 + 2". 
			Recursion depth for "1 1 1 1" and "2  2" is 4 and 2. So is the comb len.

			Complexity depends on Depth of Recursion, and  Depth of Recursion  will be max when value of coin is lowest that (" 1 1 1").  So complexity at the worst is (Sum/deapth * SrcLen)
			Width of permutation depends on Recursion depth, and Width of permutation could be anything,

							"1 1 1 1" = 4 //has width of 4
							"2 + 2" = 4 //has width of 2
			
			Recursion code
							Rec(out, o, sum)
							{
								if(sum >= 4)
									return
								for(i = 0; i < srcLen; i++)
									Rec(out, o+1, sum + src[i]);
							}

			Logic of addition is as follows:
				sum = 4
				coins = { 1, 2, 3 };

			Add just 1cent coins till the sum reaches the TargetSum. Then Eject one 1cent coin and replace it with 2cent and 3cent. Now we created SUM in 3 ways.
			1 1 1 1  //using 'all 1cents',
			1 1 1 2  //'multiple 1cents + one 2cent', Reject the combo
			1 1 1 3  //'multiple 1cents + one 3cent'  Reject the combo

			1 1 1 2 //Make sum using multiple 1cent + one 2cent. Reject the combo
			1 1 1 3 //Make sum using multiple 1cent + one 3cent.  Reject the combo  
				
           	//In the next step, eject 2 of 1cents	
			1 1 2 1 
			1 1 2 2
			1 1 2 3
			1 1 3 1
			1 1 3 2
			1 1 3 3

			Complexity in worst case is O(AverageWidth * SRcLen) = O(Sum * SRcLen)

*/

/*
			 Coin change problem (number of ways of creating TargetSum using DP) DP
				coins = 1 2 5
				Trarget sum = 12
					  1 2 3 4 5 6 7 8 9 A  B  C      ------> Target Value
					1 1 1 1 1 1 1 1 1 1 1  1  1   1c ------> Cell value shows number of combinations.
					1 1 2 2 3 3 4 4 5 5 6  6  7   2c
					1 1 2 2 3 4 5 6 7 8 10 11 13  5c


				
				This is not 0-1 problem means, we can reuse the same coins multiple times(means 5 +5 = 10).
				Solution matrix gives the number of combinations that add up to Target Sum. And row stands for coin.
				Row is cumulative vertically.

				Example for solution matrix: 
					When there is only 1-cent, and target sum is 4.  "1 + 1 + 1 + 1" makes 4, so there is only combination. 
					    So put 1 in 2nd cell.
					When there is only 2-cent, and target sum is 4.  "2 + 2" makes 4, so there is only combination. 
					    So put 1 in 2nd cell.
					When there are both 1-cent and 2-cent.
					There are three combinations. "1 1 1 1", "2 2", "2 1 1". 
					Combinations for 2-cent MUST include the combinations of 1-cent because cumulative nature.
					So put 3 in 2nd cell.
				

				When constructing the solution matrix, keep in mind 3 things.

				1) COIN that is BIGGER than SOUGHT-VALUE(column value. Ex: coin is 5cent and column is 2), 
				   can not be used for creating combination. Therefore Import the number of combs from lower coin stored in top row.
				 
				2) If the COIN is SMALLER, then we have to create the combs for two values: base-capacity and also excess-capacity.
				   Example: Cell is 5, coin is 2-cent. Here 2 is base-capacity and 3 is excess-capacity.
				   '2' will be covered by 2-cent and that leaves '3'.
				   We have to fill this excess '3' using 2-cent only, and we do that by picking the value from
				   3rd cell of SAME row.

				Note that in both cases, we have to include the combinations of 1-cent(sitting in Upper row).
				       combs = existing_

				Coming to implementation:
					We do not use Matrix, instead we use just array. This is because DP code needs just one historic row.
					We use array and initially array will have values for 1st-row.
					When constructing the 2nd row, we either keep the array-value as it is;
					OR add new value to it. This same as IMPORTING and ADDING respectively.
					ex: To get the cumulative combs, to know the combs for 2-cent, we add the value to exitsing array-value.

					Array length has to be 1 byte extra. And INIT the [0] with 1.
			*/
namespace CoinChangeMakingUsingPermNM //@RED20170818001
{
	const int LEN = 3;
	const int TRGSUM = 4;

	const int TRGSUM1 = 12;
	class CoinChangeMakingUsingPerm
	{
		public:
			void useCoinChangeMaking()
			{
				//This is based on permutations
				int TargetSum4 = TRGSUM;
				int srcLen4 = 3;
				int src4[LEN] = { 1, 2, 3 };
				int output4[4] = { 0 };
				int outIndex4 = 0;
				int Sum4 = 0;
				AddCoinsToReachTargetSum(src4, srcLen4, output4, outIndex4, TargetSum4, Sum4);

				int src5[LEN] = { 1, 2, 5 };
				NumberOfCombinationsDP(src5);
				/*
					coins = 1 2 5
					Target sum = 12
					  1 2 3 4 5 6 7 8 9 A  B  C ------> Target Value
					1 1 1 1 1 1 1 1 1 1 1  1  1 ------> Cell value shows number of combinations.
					1 1 2 2 3 3 4 4 5 5 6  6  7  2
					1 1 2 2 3 4 5 6 7 8 10 11 13
				*/
			}

		
			
			//
			
			void NumberOfCombinationsDP(int coin[LEN])
			{
				//int sol[LEN][TRGSUM1] = { 0 };
				int sol[TRGSUM1+1] = { 0 };
				for (int r = 0; r < LEN; r++)
				{
					cout << coin[r] << endl;
				}
				sol[0] = 1;
				
				//introduce one coin at a time
				for (int r = 0; r < LEN; r++)
				{
					for (int c = 0; c <= TRGSUM1; c++)
					{	

						//Always import combinations that can be created using lower coin, and this will be in top row, import it.
						//if the COIN is BIGGER than SOUGHT-VALUE(column value), 
						//then we can not use current-coin. Import the number of combs from lower coin stored in top row.
						if (coin[r] > c)
							sol[c] = sol[c];
						else if (c >= coin[r])
							sol[c] = 1 + sol[c - coin[r]];
						//if the COIN is SMALLER, we have create multiple of same coins.
						//If coin 5 and capacity is 10, then we have to use 2 coins. 
						//Here is good example (say coin is 5 and column is 7). 
						//Here the extra is 2, and try to fill that using 5. 
						//Number of combinations required for this must be in 2row of same column.
						//Note that column stands for VALUE.
					}
				}
			}


			
			void AddCoinsToReachTargetSum(int* src, int srcLen,int* output, int outIndex, int TargetSum, int Sum )
			{
			
				//Recursion breaks on two conditions, if the Target curSum == TargetSum
				//OR
				//OutIndex == SrcLen
				if (Sum == TargetSum)
				{
					cout << "following adds to " << TargetSum << endl;
					for (int i = 0; i < outIndex; i++)
					{
						cout << output[i] << " ";
					}
					cout << endl;
					cout << endl;
					return;
				}
					
					
				//Break the recursion if overall length of permutation is equal to srcLen.
				if(srcLen == outIndex)
				{
					return;
				}
				

				//Sum is UNDER TargetSUM so try to add one more SLOT to combination, and see if the SUM becomes equal to TargetSum.
				for (int i = 0; i < srcLen; i++) //'count - count' is same as index so use "<="
				{
					//Fill the current-slot or column
					output[outIndex] = src[i];
					cout << "output[" << outIndex << "] = '" << output[outIndex] << "'" << endl;

					//RECURSE for filling the slot that is RIGHT of current-slot. 
					//ADD the value of current-slot to SUM.
					//SUM should reflect the summ of whatever is already in output[]
					AddCoinsToReachTargetSum(src, srcLen,  output, outIndex + 1, TargetSum, Sum + src[i]);
				}
			}
	};
};

